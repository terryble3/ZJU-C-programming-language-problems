# 如何做一道浙大C程理论考题

## 第一部分 选择题

>   若变量已正确定义，表达式` (j=3, j++) `的值是_____ 。(2000)(表达式求值)
> 
> A、3          
> 
> B、4           
> 
> C、5            
> 
> D、0

 正解：A  

 **对于逗号表达式，其整个表达式的值为最后一个表达式的值**，所以` (j=3, j++) `表达式的值最后就是j++的值。后置自增在表达式执行结束后生效。

>已知字符 ‘a’ 的ASCII码为 97 ，执行下列语句的输出是_____。(2000)(格式化输出)
> 
> `printf ("%d, %c", ’b’, ’b’+1 ) ;`
> 
> A、98, b        
> 
> B、语句不合法    
> 
> C、98, 99      
> 
> D、98, c

正解：D

格式控制字符串用于指定输出格式。%d输出字符常量'b'的ASCII码（比'a'大1即98），%c输出ASCII码对应字符常量（ASCII码比'b'大1即C）。

>表达式`strcmp(“box”, “boss”) `的值是一个_______。(2000)(字符串处理函数)
>
>A、正数
>
>B、负数
>
>C、 0
>
>D、 不确定的数

正解：A

`strcmp(*s1, *s2)`接受两个char类型的指针作为参数。比较时两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇'\0'为止。当s1<s2时返回负数；当s1=s2时，返回值= 0；当s1>s2时，返回正数。本题中'x'>'s'，所以返回一个正数。

>数组定义为 `int a[3][2]={1, 2, 3, 4, 5, 6}`，数组元素_____的值为6。(2000)(数组)
>
>A、a[3][2]
>
>B、a[2][1]
>
>C、a[1][2]
>
>D、a[2][3]

正解：B

C语言二维数组初始化时可以将列数溢出到下一行。注意数组下标引用时从0开始。所以值为6的元素在“第三行第二列”，即a[2][1]。

>判断i和j至少有一个值为非0的表达式是_____。(2000)(表达式求值)
>
>A、`i!=0 && j!=0`
>
>B、`i*j!=0`
>
>C、`!(i==0 || j==0)`
>
>D、`i&&j`

正解：B

A中关系运算符 != 优先级比逻辑运算符 && 优先级高，为真的条件是 i 和 j 均不等于0 ; B为真的条件是 i 和 j 之积不等于0，即 i 和 j 中至少有一个不等于0 ; C相当于 i 或 j 有一个等于0即为假，即要求 i 和 j 都不等于0 ; D为真的条件是 i 和 j 都不为 0 。

>若a是基本整型变量，c是单精度实型变量，输入语句______是错误的。(2000)(格式化输入)
>
>A、`scanf(”%d,%f”, &a, &c);`         
>
>B、`scanf(”d=%d, c=%f”, &a, &c);`
>
>C、`scanf(”%d%f”, &a, &c)`;           
>
>D、`scanf(”%d%f”, a, c);`

正解：D

D错在输入时没有在变量前加地址运算符`&`。

>若变量已正确定义并且指针p已经指向某个变量x，则(*p)++相当于_____。(2000)(指针)
>
>A、`p++`
>
>B、`x++`
>
>C、`*(p++)`
>
>D、`&x++`

正解：B

由于括号的存在`(*p)++`先对p解引用，后置自增的对象即为指针p指向的变量x。`p++`作用是使p指向下一个存储单元。`*(p++)`含义是p指向的存储单元的下一个存储单元中存放的变量。`&x++`由于单目运算符的结合方向自右向左，先执行自增再取地址。

>下列程序段的输出是_____。(2000)(指针)
>```c
>int c[]={1, 3, 5};
>
>int *k=c+1;
>
>printf("%d", *++k);
>```
>A、3
>
>B、5
>
>C、4
>
>D、6

正解：B

```c
int *k=c+1;
```
将c[0]后一个元素的地址赋给了k。前置自增和解引用的优先级相同，结合性使从右往左，所以输出时`*++k`指向的是c[2]。

>不正确的赋值或赋初值的方式是______。(2000)(字符串数组)
>
>A、`char str[]="string"；`
>         
>B、`char str[7]={'s', 't', 'r', 'i', 'n', 'g'}；`
>
>C、`char str[10]；str="string"；`
>
>D、`char str[7]={'s', 't', 'r', 'i', 'n', 'g', ’\0’}；`

正解：C

当为已经完成定义的字符数组赋值时，不能采用类似于初始化的方式为字符数组赋值了。错误的原因是字符数组名代表字符数组的首地址，不可修改，不能作为左值。

>对于以下结构定义，++p->str中的++加在_____。(2000)(指针)
>```c
>	struct { 
>       int len; 
>	    char *str;
>	} *p;
>```
>A、指针str上
>
>B、指针p上
>       
>C、str指的内容上   
>
>D、以上均不是

正解:A

成员选择(指针)运算符的优先级比自增运算符高。该结构中的str是一个指针变量,自增加在指针str上。

>对于如下说明，语法和语义都正确的赋值是_____。(2000)(指针)
>```c
>	int c, *s, a[]={1, 3, 5};
>```
>A、`c=*s; `   
>     
>B、`s[0]=a[0]; `
>     
>C、`s=&a[1]; `   
>    
>D、`c=a;`

正解:C

A指针未初始化；B指针s未初始化；C使s的值为数组a第二个元素的地址,正确；D把数组首元素地址赋给变量c,语义不正确。

>表达式 `!(x>0||y>0)` 等价于_____。(2002)(表达式求值)
>
>A．`!(x>0)&&!(y>0)`
>
>B．`!x>0&&!y>0	`
>
>C．`!x>0||!y>0	`
>
>D．`!(x>0)||!(y>0)`

正解: A

表达式 `!(x>0||y>0)` 为真的条件是x, y都小于等于0。B为真的条件是(!x)和(!y)都大于0(!的优先级比&&高)，即x和y都等于0。C为真的条件是(!x)或(!y)大于0，即x或y等于0。D为真的条件是x或y小于等于0。

>若 x 是浮点型变量，表达式 (x=10/4) 的值是_____ 。(2002)(表达式求值)
>
>A．2.5
>
>B．2.0
>
>C．3
>
>D．2

正解：B

x是浮点型变量但(10/4)是整型除法小数部分截断。

>对于变量定义 `int a[10], *p=a;`，表达式______是不正确的。(2002)(指针)
>
>A．`a[9]`
>
>B．`p[5]`
>
>C．`*p++`
>
>D．`a++`

正解：D

语句`int a[10], *p=a;`将数组a首元素的地址赋给指针变量p。D错在数组a是指针常量，不是变量，所以像a=p、a++、a+=2这样的表达式都是非法的，不能改变指针常量的值。

>设程序中不再定义和声明变量，写出在函数fun中可以使用的所有变量______。(2002)(变量作用域)
>```c
>    #include <stdio.h>
>    void fun(int x)
>{  static int y;
>       ……
>       return;
>    }
>    int z;
>    void main( )
>    {   int a,b;
>        fun(a);
>        ……
>    }
>```
>A．x, y
>	
>B．x, y, z	
>
>C．a,b,y,z	
>
>D．a,b,x,y,z

正解：A

函数f可以使用其形参x和内部定义的静态变量y。全局变量z由于声明在f后所以f不能使用。a, b是main函数内部的变量f不能使用。

>对于变量定义 `int p[5], *a[5];`，表达式______是正确的。(2002)(指针)
>
>A．`p=a`	
>
>B．`p[0]=a `	
>
>C．`*(a+1)=p`
>
>D．`a[0]=2`

正解：C

`int p[5], *a[5];`定义了一个5个元素的数组p和5个元素的指针数组（[]优先级比*高）。A错在p是指针常量，不是变量，不能改变指针常量的值。B错在将一个指针常量的值（地址）赋给一个int型的数组元素。C将p首元素的地址赋给a中的第二个元素。D错在将一个值非0的常量赋给一个指针变量。

>对于以下的变量定义，表达式______是不正确的。(2003)(指针)
>```c
>	struct node {
>		float x, y;
>	} point, *p=&point;
>```
>
>A．`p->x=2.0`	
>
>B．`(*p).y=3.0	`
>
>C．`point.x=2.0`
>
>D．`*p->y=3.0`

正解：D

注意`*p->y=3.0`中->的优先级比*高，正确的表达式应为`p->y=3.0`

>对于变量定义：`int **p[10]`, p 是一个______。(2003)(指针)
>
>A．指针	
>
>B．数组	
>
>C．函数	
>
>D．数组元素

正解：B

`*p[10]`是一个指针数组，`**p[10]`可理解为对指针数组中的每个指针解引用构成一个数组。

>下面C语言的标识符中,哪个不合法______。(2005)(标识符)
>
>A．_total	
>
>B．Large tall	
>
>C．int_	
>
>D．_while

正解：B

C语言规定，标识符只能由字母（A~Z, a~z）、数字（0~9）和下划线（_）组成，并且第一个字符必须是字母或下划线，不能是数字。B项中有空格。

>若变量k已正确定义且k的值是4，计算表达式`(j=k++)`后，______。(2005)(表达式求值)
>
>A．k=4,j=4	
>
>B．j=4,k=5	
>
>C．j=5,k=4	
>
>D．j=5,k=5

正解：B

由于自增运算符后置，先将k=4的值赋给j，再k加1。

>C语言中，函数若没有声明返回值的类型，默认的类型是_______。(2005)(函数)
>
>A．int
> 	
>B．long
>	
>C．float	
>
>D．double 

正解：A

C语言中，函数若没有声明返回值的类型，默认的类型是int。

>若p1和p2都是指向int类型变量的指针，p1已经指向变量x,要使p2也指向x，则_____是正确的。(2005)(指针)
>
>A．`p2=&*p1;`	
>
>B．`p2=&&p1;`
>	
>C．`p2=&p1;`
>
>D．`p2=*p1;`

正解：A

&相当于*的逆运算。

>设有结构定义如下：
>```c
>struct student{
>  int num;
>  char name[30];
>  float score;
>}stud1;
>```
>则标准的ANSI C(如TC)下，计算sizeof(stud1)的值为____________。(2005)(数据类型)
>
>A．9	
>
>B．16	
>
>C．25	
>
>D．36

正解：36

sizeof(stud1) = 2(int num) + 30(char name[30]) + 4(float score) = 36.

>在C语言中,下面描述正确的是：_____。(2006)(函数)
>
>A、函数的定义可以嵌套，但函数的调用不可以嵌套
>
>B、函数的定义不可以嵌套，但函数的调用不可以嵌套
>
>C、函数的定义可以嵌套，函数的调用也可以嵌套
>
>D、函数的定义不可以嵌套，但函数的调用可以嵌套

正解：D

>在C语言中，_____存储类型的变量，只在使用时才分配空间。(2006)(存储类型)
>
> A、static和auto 
>        
> B、register和extern
> 
> C、register和static  
>  
> D、auto和register

正解：D

auto, static, extern, register是C语言的四种变量存储类型

auto称为自动变量（局部变量）。局部变量是指在函数内部说明的变量（有时也称为自动变量）。所有的非全程变量都被认为是局部变量。局部变量在函数调用时自动产生，但不会自动初始化，随函数调用的结束，这个变量也就自动消失了。下次调用此函数时再自动产生，还要再赋值，退出时又自动消失。

static称为静态变量。根据变量的类型可以分为静态局部变量和静态全局变量。静态局部变量与局部变量的区别在于：在函数退出时，这个变量始终存在，但不能被其它函数使用；当再次进入该函数时，将保存上次的结果。其它与局部变量一样。静态全程变量只在定义它的源文件中可见而在其它源文件中不可见的变量，与全局变量的区别是：全局变量可以被其它源文件使用，而静态全局变量只能被所在的源文件使用。

extern称为外部申明。为了使变量或者函数除了在定义它的源文件中可以使用外，还可以被其它文件使用。

register称为寄存器变量。它只能用于整型和字符型变量。定义符register说明的变量被存储在CPU的寄存器中。

>有程序段如下：
>```c
>     Int k=10;
>     While(k=0)
>       K=k-1;
>```
>以下选项中描述正确的是_____。(2006)(表达式求值)
>
>A. 语句“k=k-1;”被执行10次。
>       
>B. 语句“k=k-1;”被执行1次。
>
>C. 语句“k=k-1;”被执行无限多次。   
>
>D. 语句“k=k-1;”一次也不执行。

正解：D

注意到while循环的判断部分表达式是`k=0`，返回k的值，区别于`k==0`。

>有程序段如下：
>```c
>     int a=1,b=2,c=3;
>     if(a>b)
>       c=a;a=b;b=c;
>```
>执行该程序段后，变量a,b,c的值是_____。(2006)
>
>A. a=1,b=2,c=3     
>
>B. a=2,b=3,c=3
>
>C. a=2,b=3,c=1  
>
>D. a=3,b=2,c=1

正解：B

由于if后没有大括号，if中只包含`c=a`一条语句，`a=b;b=c;`一定会执行。由于进入if语句的条件不成立
，`c=a`不执行，只执行`a=b;b=c;`。

>假设所有变量均为int类型，则表达式`(a=2,b=5,b+1,a+b)`的值为______。(2006)(表达式求值)
>
>A．7 
>
>B．8 
>
>C．6 
>
>D．2

正解：A

对于逗号表达式，其整个表达式的值为最后一个表达式的值。`b+1`并不改变b的值，所以整个表达式的值即为`a+b`=2+5=7。

>以下叙述正确的是 ______。(2006)
>
>A. 在C程序中，main()函数必须位于程序的最前面。
>
>B. C程序的每一行中只能写一条语句。
>
>C. 在对C程序进行编译的过程中，可发现注释中的拼写错误。
>
>D. C语言本身没有输入、输出语句。

正解：D

A：main()函数前还可以有预处理器指令、其他函数、全局变量声明等。B：C程序的一行中可以写多条语句。C：注释会被编译器忽略，自然也就无从发现拼写错误。D：C语言本身并不提供输入输出语句，输入和输出操作是由函数来实现的。在C标准函数库中提供了一些输入输出函数，例如，printf函数和scanf函数，它们不是C语言中的组成部分。

>设有语句
>```c
> struct st
>   { int n;
>     int *t; }*p;
>   static struct st s[3]={5,'\0',7,'\0',9,'\0'};
>   p=s;
>```
>   则`printf(“%d\n”,______)`的值是6。(2006)(指针)
> 
>A．`p++->n`
>
>B．`p->n++` 
>
>C．`(*p).n++` 
>
>D．`++p->n`

正解：D

>设有语句：`int a[10]={0,1,2,3,4,5,6,7,8,9},*p=a;`则以下______不是对a数组元素的正确引用，其中0≤i<10。(2006)(指针)
>
>A．`a[p-a]` 
>
>B．`*(&a[i])`
>
>C．`p[i]`
>
>D．`*(*(a+i))`

正解：D

`int a[10]={0,1,2,3,4,5,6,7,8,9},*p=a;`声明了一个数组a和一个指向a的指针p。A：p-a=0，相当于a[p-a]。B：先取地址再解引用，相当于a[i]。C：相当于a[i]。D：*(a+i)相当于a[i]，再解引用则引用错误。

## 第二部分 填空/程序阅读题

>写出下列程序段的输出结果。(2000)(宏)
>
>   ```c
>    #define  A  10
>    #define  B  (A<A+2)-2
>    printf("%d", B*2);
>   ```

正解：3

先将B代入：(A<A+2)-2\*2；再将A代入：(10<10+2)-2\*2。加运算符优先级高于小于运算符，`(10<10+2)-2\*2`=`(10<12)-4`=`1-4`=-3。

>写出下列程序段的输出结果。(2000)(循环条件)
>```c
>    int k, x;
>    for (k=0, x=0; k<=9&&x!=10; k++)
>       x+=2;
>    printf ("%d, %d", k, x) ;
> ```

正解：5, 10

k和x初值均为0；进入循环的条件k<=9且x不等于10；每次循环结束k加1。每次进入循环x加2。循环结束时x=10，循环5次k加1五次，k=5。

>对于以下递归函数f，调用 f (3) 的返回值是_____。(2000)(函数递归)
>```c
>    f (int n)
>    {   return ((n>0) ? 2*f(n-1)+f(n-2) : -1);  }
>```
正解：-17

语句`((n>0) ? 2*f(n-1)+f(n-2) : -1);`中优先级()最高，*次之，+次之，?:次之。所以n>0时返回`2*f(n-1)+f(n-2)`，否则返回-1。

f(3) = 2*f(2)+f(1)

f(2) = 2*f(1)+f(0)

f(1) = 2*f(0)+f(-1)

得f(1) = -3; f(2) = -7; f(3) = -17。

>写出下列程序段的输出结果。(2000)(字符串数组)
>```c
>    char str[]="hello\tworld\n";
>    printf("%d, %c\n", sizeof(str), *(str+10));
> ```

正解：13, d

\t和\n是转义字符，加上末尾\0字符串数组中共13个字符常量。`*(str+10)`指向的是str[10]，即'd'。

>若输入89 76 24 25 9 8 11 16 35 4 <回车> ,  则以下程序的输出结果是_______。(2000)(排序)
>```c
>    #include "stdio.h"
>    #define N 10
>    main()
>    {  
>      int x[N], y1[N], y2[N];
>      int i, j, n1, n2, t, p;
>      n1=n2=0;
>      for(i=0;i<N;i++){
>         scanf(“%d”, &x[i]);
>         if(x[i] % 2==0)  y1[n1++]=x[i];
>         else  y2[n2++]=x[i];
>      }
>      for(i=1; i<n1; i++)
>         for(j=0; j<n1-1; j++)
>    	     if(y1[j]>y1[j+1]){
>	         t=y1[j]; y1[j]=y1[j+1]; y1[j+1]=t;
>    	     }
>      for(i=0; i<n2-1; i++){
>         p=i;
>         for(j=i+1; j<n2; j++) 
>             if(y2[p]<y2[j]) p=j;
>         if(p!=i){
>    	         t=y2[i]; y2[i]=y2[p]; y2[p]=t;
>         }
>      }
>      for(i=0; i<n1; i++) printf("%d, ", y1[i]);
>      for(i=0; i<n2; i++) printf("%d, ", y2[i]);
>```

正解：4, 8, 16, 24, 76, 89, 35, 25, 11, 9,

第一个for循环读入一串数字并将偶数存入数组y1中，将奇数存入数组y2中。第二、三个for循环对y1从小到大冒泡排序。第四、五个for循环对y2从大到小选择排序。

>以下程序的输出结果是_______。(2000)(函数作用域)
>```c
>    #include <stdio.h>
>    int z;
>    void p(int *x, int y)
>	 {    ++*x;
>     	  y--;
>         z=*x+y+z;
>         printf("%d, %d, %d#", *x, y, z);
>	 }
>    void main()
>    {    int x=1, y=5, z=9;
>         p(&x, y);
>         printf("%d, %d, %d#", x, y, z);
>    }
> ```

正解：2, 4, 6#2, 5, 9#

程序有两个printf语句输出。函数p中`++*x;`指针操作改变了x的值；y是p的形参，在p中被改变了值（-1）,但不影响main函数中实参y的值；p中的变量z是全局变量（未初始化，初值为0）。在main函数中x的值被改变（+1），y的值不受影响，由于main函数中声明了和全局变量同名的局部变量z，因此printf语句中z取局部变量的值（9）。

>若输入 -6+15*3/5=<回车> ,  则以下程序的输出结果是_______。(2000)
>```c
>   #include <stdio.h>
>   void main()
>   { 
>       int m=0, sum=0;
>       char c, oldc='+';
>   do {
>       c=getchar();
>	       if(c<='9'&&c>='0')  m=10*m+c - '0';
>	       else {
>              if(oldc=='+') sum += m;
>	          else sum -= m;
>	          m=0;
>	          oldc=c;
>              printf("%d, ", sum);
>           }
>       }  while(c!='=');
>    }
>```

正解：0, -6, 9, 6, 1,

程序以字符形式读入操作数和运算符。遇到加号将前一个操作数加到变量sum上并输出sum值；遇到其他运算符均作减号等效的处理将从sum中减前一个操作数并输出sum值。

>下列程序段的输出结果是_____。(2002)(循环)  
>```c
>int k, s;
>	for(k=1, s=0; k<10; k++){
>	    if (k%2==0) continue; 
>         s += k; 
>   }
>printf("k=%d s=%d", k, s);
>```

正解：k=10 s=25

k的初值为1，s的初值为0。k<10则进入循环。进入循环后判断k是否能被2整除，是则跳过循环剩余部分，否则s的值增加k。
每一轮循环后k和s的值分别为：

| 循环轮数 | k值 | s值 |
| :----: | :----: | :----: |
| 1 | 2 | 1 |
| 2 | 3 | 1 |
| 3 | 4 | 4 |
| 4 | 5 | 4 |
| 5 | 6 | 9 |
| 6 | 7 | 9 |
| 7 | 8 | 16 |
| 8 | 9 | 16 |
| 9 | 10 | 25 |

>下列程序段的输出结果是_____。(2002)(宏)  
>```c
>    #define MM(x,y)   (x*y)
>    printf("%d", MM(2+3,15));
>```

正解：47

MM(2+3,15)替换后为2+3*15=47。

>下列程序段的输出结果是_____。(2002)(switch)
>```c  
>int k=1, s=0;
>switch (k) {
>      case 1: s+=10; 
>      case 2: s+=20; break;
>      default: s+=3; 
>}
>printf("k=%d s=%d", k, s);
>```

正解：k=1 s=30

因为k=1，执行`s+=10`，此后s=10，接着执行`s+=20`，此后s=30，之后遇到`break;`跳出switch，输出。过程中k值无变化。

>下列程序的输出结果是_____。(2002)(静态变量)
>```c
># include <stdio.h>
>int f( )                      
>{   static int k; 
>     return ++k;
>}
>void main( )
>{  int k;
>    for(k=0;k<3;k++)
>      printf("%d#", f( ));
>}

正解：1#2#3#

注意k在函数f()中定义为静态变量，只进行一次初始化。

>下列程序段的输出结果是_____。(2002)(指针)
>```c 
>int k=1, j=2, *p, *q, *t; 
>p=&k; q=&j;
>t=p; p=q; q=t;
>printf("%d, %d",*p, k);
>```

正解：2, 1

`p=&k; q=&j;`将k的地址赋给p，将j的地址赋给q。`t=p; p=q; q=t;`交换p和q的内容，于是p此时指向j，而k的值并未改变。

>下列程序段的输出结果是_____。(2002)(数组)
>```c
>int c[ ]={10, 30, 5};
>int *pc;
>for(pc=c; pc<c+2; pc++)
>   printf("%d#", *pc);
>```

正解：10#30#

c是数组首元素的地址，循环进行了两轮。

>下列程序段的输出结果是_____。(2002)(指针数组)  
>```c
>char  *st[ ]={"ONE","TWO","FOUR","K"};
>printf("%s, %c\n", *(st+2), **st+1);

正解：FOUR, P

`char  *st[ ]={"ONE","TWO","FOUR","K"};`声明了一个指针数组st，每个元素是字符串首个字符的地址。`*(st+2)`即为数组st的第三个元素为地址开头的字符串。`**st+1`中*的优先级比+高，`*st`的值是"ONE"首个字符的地址，`**st`指向"O"，**st+1即为P。

>下列程序的输出结果是_____。(2002)(函数)
>```c
>#include <stdio.h>
>void p(int *x,int y)
>{  ++*x;
>   y=y+2;
>}
>void main()
>    {  int x=0, y=3;
>       p(&y, y);
>       printf("%d, %d", x, y);
>    }
>```

正解：0,4

`++*x`由于运算符的右结合性，先对指针解引用，再将指针指向变量加1。而`y=y+2`由于y是函数中的形参并不影响原函数中实参的值。x的值同理不改变。

>下列程序的输出结果是_______。(2002)(循环)
>```c
>    #include <stdio.h>
>    void main( )
>    {
>        int k, x, s, t;
>
>        x=3;
>        s=0; t=x;
>        for(k=1; k<=3; k++){
>            t=t*10+x;
>            s=s+t; 
>           printf("%d#", s);
>        }
>    }
> ```    

正解：33#366#3699#

| 循环轮数 | s值 | t值 |
| :----: | :----: | :----: |
| 进入前 | 0 | 3 |
| 1 | 33 | 33 |
| 2 | 366 | 333 |
| 3 | 3699 | 3333 |

>输入3  9 8 6 5 3 7 1 2 4  2  1 2 3 4<回车>后，下列程序的输出结果是_______。(2002)
>```c
>#include "stdio.h"
>void main( )
>{  
>	  int flag,i,j,k,col,n,ri,a[6][6];
>       for(ri=1; ri<=2; ri++){
>          scanf("%d",&n);
>          for(i=0; i<n; i++)
>             for(j=0; j<n; j++)
>                  scanf("%d",&a[i][j]);
>          flag=0;
>          for(i=0; i<n; i++){
>	         col=0;
>              for(j=0; j<n; j++)
>	              if (a[i][col]<a[i][j])  col=j;
>              for (k=0; k<n; k++)
>	              if(a[i][col]<a[k][col])   break;
>	         if(k>=n){
>			      printf("a[%d][%d]=%d#", i, col,a[i][col]);
>                  flag=1;
>		     }
>          }
>          if(!flag)  printf("NO#");
>       }
>}
>```

正解：a[0][0]=9#a[1][2]=7#a[1][1]=4

```c
scanf("%d",&n);
for(i=0; i<n; i++)
    for(j=0; j<n; j++)
        scanf("%d",&a[i][j]);
```
读取n，再读取n行n列的矩阵，本题中第一个矩阵为

9 8 6

5 3 7

1 2 4

第二个矩阵为

1 2

3 4

```c
for(i=0; i<n; i++){
	col=0;
    for(j=0; j<n; j++)
	    if (a[i][col]<a[i][j])  col=j;//找到最大元素所在行
        for (k=0; k<n; k++)
	        if(a[i][col]<a[k][col])   break;//再在该行查找是否有比该元素更大的数，有则跳出循环
	        if(k>=n){//如果没有找到那么这个元素在其所在行和所在列都是最大的，输出
			    printf("a[%d][%d]=%d#", i, col,a[i][col]);
                flag=1;
		     }
```
这一部分的作用见注释。

>输入how are you?<回车>后，下列程序的输出结果是_______。(2002)
>```c
>#include <stdio.h>
>void main( )
>{
>    int word;
>		char ch;
>        
>    word=0;
>		while((ch=getchar())!='?'){
>			if(ch==' ') word=0;
>			else if(word==0){
>				word=1;
>				if(ch<='z'&&ch>='a')
>					ch=ch-'a'+'A';
>			}
>			putchar(ch);
>		}
>}
>```

正解：How Are You

程序的作用是将输入的字符串中每个单词的首字母（如果为小写）转换为大写。各部分作用见注释。

```c
#include <stdio.h>
void main( )
{
    int word;
	char ch;
        
    word=0;
	while((ch=getchar())!='?'){//读入字符到ch中，如果不是'?'则进入循环
		if(ch==' ') word=0;//读入空格时将word置0
		else if(word==0){//读入的不是空格且之前无空格外字符（即该字母为单词首字母）
				word=1;
				if(ch<='z'&&ch>='a')//判断该字符是否为小写字母
					ch=ch-'a'+'A';//将小写转换为大写
		}
		putchar(ch);
		}
}
```

>假设文本文件a.txt中存放了下列数据：
>
>one?two?1234?output?
>
>文本文件b.txt中存放了下列数据：
>
>one?two?1204?input?
>
>下列程序的输出结果是_______。(2002)(文件)
>```c
># include <stdio.h>
># include <stdlib.h>
>void main()
>{   int count;
>	 char ch1,ch2;
>    FILE *f1, *f2;
>
>	 if ((f1 = fopen("a.txt","r")) == NULL){
>         printf("Can't open file : %s\n", "a.txt");
>		exit(0);
>		}
>	 if ((f2 = fopen("b.txt","r")) == NULL){
>         printf("Can't open file : %s\n", "b.txt");
>		exit(0);
>		}
>	    count=0;
>	 while (!feof(f1)||!feof(f2)){
>         ch1=fgetc(f1);
>	    ch2=fgetc(f2);
>	    if(ch1!=ch2){
>           printf("%c#%c#",ch1,ch2);
>	      printf("%d#", count);
>	      break;
>	      }
>	      if(ch1=='?') count++;
>	    }
>	    fclose(f1);
>	    fclose(f2);
>}
>```

程序的作用是逐个两文件（如果均能打开）中的字符，输出第一对不同的字符及至此读取到几个'?'。其中比较部分程序段作用见注释。

```c
	while (!feof(f1)||!feof(f2)){//当设置了与流关联的文件结束标识符时，feof()返回一个非零值，否则返回零。f1或f2没到结尾即进入循环
       ch1=fgetc(f1);//fgetc()从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动
	   ch2=fgetc(f2);
	   if(ch1!=ch2){
          printf("%c#%c#",ch1,ch2);
	      printf("%d#", count);
	      break;//该对字符不相同时跳出while循环
	   }
	   if(ch1=='?') count++;
	}
```
>下列程序段的输出结果是_____。(2003)(宏)  
>```c
>    #define MM(x,y)   (x)+(y)
>    printf("%d", MM(2*3,15)*2);
>```

正解：36

替换后`MM(2*3,15)*2`为(2*3)+(15)*2 = 36。

>下列程序段的输出结果是_____。(2003)(指针)
>``` c
>	char  *st[ ]={"ONE","TWO","FOUR","K"};
>	printf("%s, %c\n", *(st+1)+1, *(*(st+2)+2)-1);
>```

正解：WO,T

`*st[ ]`是一个指针数组，其中每个元素是对应字符串首字符地址。`*(st+1)+1`定位到第二个字符串第二个字符的位置，所以从W开始输出"TWO"，`*(*(st+2)+2)-1`先定位到第三个字符串第三个字符的位置再解引用，即U，最后减1，输出T。

>下列程序的输出结果是_____。(2003)(指针)
>```c
>#include <stdio.h>
>void p(int *x,int *y)
>{  int *p;
>   p=x; x=y; y=p;
>}
>void main()
>{  int x=0, y=3;
>   p(&y, &x);
>   printf("%d, %d", x, y);
>}
>```

正解：0,3

本题中，函数p只是交换x和y存放的地址，不影响x和y的值。

>输入2  59  60 <回车>后，下列程序的输出结果是_______。(2003)(循环)
>```c
>#include <stdio.h>
>void main( )
>{  int ri, repeat;
>   int mark;
>   scanf("%d", &repeat);
>   for(ri=1; ri<=repeat; ri++)
>      scanf("%d",&mark);
>      if(mark >= 60) 
>          printf("Pass");
>      else
>          printf("Fail");
>}
>```

正解：Pass

易错之处在于for函数题中只有一条语句`scanf("%d",&mark);`，`if`部分只判断最后一个mark值。

>写出语句`printf(“%d,%o,%x”,’a’/4,0x14,014);`的输出结果__________。

正解：24,24,c

'a'的ASCII码为96，0x14是以十六进制表示的十进制数20，转换为八进制数(%o)为24，014是以八进制表示的十进制数12，转换为十六进制数(%x)为c。

>下列程序段的输出结果是______________________。(2005)(静态变量)
>```c
>#include “stdio.h"
>int x;
>void f(int x)
>{static int a=1;
> printf(“%d,”,a);
> a+=x+2;
>}
>void main()
>{int k;
> for(k=1;k<=3;k++)
>  f(k);
>}
>```
正解：1,4,8

`static int a=1`声明了一个静态变量a并初始化值为1（a只初始化一次），此后a的值在函数调用结束后被保存。第一次调用f，输出a的值为1，`a+=x+2;`由于+的优先级比+=高，a加3等于4。第二次调用f先输出4，再a加4等于8。第三次调用先输出8，再a加5等于13。

>对于以下递归函数f,调用f(4)的返回值是_______________________。(2005)(递归函数)
>```c
>   f(int n)
>   {return((n>0)?2*f(n-1)+f(n-2):1);}

正解：41

`return((n>0)?2*f(n-1)+f(n-2):1);`即若参数n大于0，f的返回值为`2*f(n-1)+f(n-2)`，否则为1。所以有f(4)=2*f(3)+f(2);f(3)=2*f(2)+f(1);f(2)=2*f(1)+f(0);f(1)=2*f(0)+f(-1);f(0)=1;f(-1)=1。将f(0)和f(1)的值回代即可得f(4)=41。

>下列程序的输出结果是_____________。(2005)(指针)
>```c
>int p,q,k=3,j=4;
>q=&k;p=q;q=&j;
>printf(“%d”,*p);
>```

正解：3

`q=&k;`使指针q指向k，`p=q;`使p也指向q指向的k。因此`printf(“%d”,*p);`输出的即为k的值3。

>下面函数定义中的错误是_____________。(2005)(函数)
>```c
>double sum(double x,y)
>{return(x*x+y*y);
>}
>```

正解：对形参y必须作类型说明

函数的形参均需类型说明。

>下列程序的输出结果是___________________。(2005)(排序)
>```c
># include <stdio.h>
>void sort(int b[],intn,int x)
>{ int k;
> for(k=n-1;k>=0;k--)
>  if(b[k]<x)
>    b[k+1]=b[k];
>  else
>    break;
>  b[k+1]=x;
>}
>void main()
>{int I,j;
> static int a[5]={8,5,7,2,6};
> int b[8];
> b[0]=a[0];
> for(i=1;i<5;i++)
>{sort(b,i,a[i]);
> for(j=0;j<=i;j++)printf(“%d  “,b[j]);
> printf(“\n”);
>}
>}

正解：

8 5

8 7 5

8 7 5 2

8 7 6 5 2


程序的作用是对给定的一个数组从大到小排序，并将结果存放在另一个数组中，最后输出排序后数组，使用的是插入排序算法，每插入一个数就输出一次插入后结果，换行，直到排序结束。

>输入12345后，下列程序的输出结果是___________________。(2005)(迭代函数)
>```c
>#include “stdio.h”
>int fun(); 
>void main()
>{ fun();}
>int fun()
>{ char c;
>if((c=getchar())!=’\n’) fun();
>putchar(c);
>}

正解：

\n
    
54321


程序从main函数处开始执行，调用fun函数。fun函数读取一个字符，非回车则继续调用fun函数；直到最后一个fun函数读取到回车，这个fun函数才执行`putchar(c);`输出回车。最后一层函数执行完毕，调用这个函数的倒数第二层fun函数也进入`putchar(c);`这一步……整个程序相当于读入字符串直至回车，并将包括回车在内倒序输出的效果。

>`int a=3`，则`a+=a-=a*a`的值是_____。(2006)(表达式求值)

正解：-12

`a+=a-=a*a`中*优先级最高，+=和-=相同且为右结合。首先计算a*a=9，再计算a-=9，运算后a=-6，最后计算a+=-6，运算后a=-12。

>表达式`3<5<2`的值是_____。(2006)(表达式求值)

正解：1

<的结合性为从左到右，所以先计算3<5，为真所以表达式值为1，再计算1<2，为真所以值为1，综上整个表达式值为1。

>下列程序段的输出结果是_____。(2006)(宏)  
>```c
>    #define A1(a,b)  a*b
>    #define A2(a,b)  (a*b)
>    printf("%d\n",2*A2(A1(2,-1),A2(2,-1)));
>```

正解：8

先替换内层，替换后`2*A2(A1(2,-1),A2(2,-1))`转化为`2*A2(2*-1,(2*-1))`，再替换外层转化为2*(2*-1*(2*-1))=8。

>执行下面的程序段后，a和b的值分别是_____。(2006)(表达式求值)
>```c
>int a=3,b=5,c;
>c=(a>--b) ? a++ : b--;
>```
首先计算括号内部分，括号内--优先级高于>，计算后b=4，因为a<4，所以括号内部分为假，`(a>--b) ? a++ : b--`的取b--的值4，此后b要自减1；整个过程中a的值无变化。所以a=3，b=3。
